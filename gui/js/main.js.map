{"version":3,"sources":["prism.js","main.js"],"names":["document","createElement","window","querySelector","classList","add","self","WorkerGlobalScope","Prism","lang","_","util","encode","tokens","Token","type","content","alias","map","replace","o","Object","prototype","toString","call","match","clone","key","hasOwnProperty","slice","languages","extend","id","redef","insertBefore","inside","before","insert","root","grammar","arguments","length","newToken","ret","token","DFS","value","this","callback","i","highlightAll","async","element","elements","querySelectorAll","highlightElement","language","parent","test","className","parentNode","nodeName","code","textContent","env","hooks","run","Worker","worker","filename","onmessage","evt","highlightedCode","stringify","JSON","parse","data","innerHTML","postMessage","highlight","text","tokenize","strarr","rest","tokenloop","patterns","j","pattern","lookbehind","lookbehindLength","str","lastIndex","exec","from","index","len","to","after","args","push","wrapped","Array","splice","apply","all","name","callbacks","join","tag","classes","attributes","aliases","addEventListener","message","close","script","getElementsByTagName","src","hasAttribute","module","exports","markup","comment","prolog","doctype","cdata","punctuation","namespace","attr-value","attr-name","entity","css","atrule","url","selector","property","string","important","function","style","style-attr","pseudo-element","pseudo-class","class","hexcode","number","clike","class-name","keyword","boolean","operator","ignore","javascript","regex","bash","git","command","parameter","coord","deleted","inserted","commit_sha1"],"mappings":"AAAA,GCOA,iBAAAA,WAAA,aAAAA,UAAAC,cAAA,MAAA,oBAAAC,SAGAF,SAAAG,cAAA,QAAAC,UAAAC,IAAA,MDVA,iBAAAL,WAAA,aAAAA,UAAAC,cAAA,MAAA,oBAAAC,QAAA,CAGAI,KAAA,mBAAAJ,QACAA,OAEA,mBAAAK,oBAAAD,eAAAC,mBACAD,OAUA,IAAAE,OAAA,WAGA,GAAAC,MAAA,iCAEAC,EAAAJ,KAAAE,OACAG,MACAC,OAAA,SAAAC,QACA,MAAAA,kBAAAC,OACA,GAAAA,OAAAD,OAAAE,KAAAL,EAAAC,KAAAC,OAAAC,OAAAG,SAAAH,OAAAI,OACA,UAAAP,EAAAC,KAAAI,KAAAF,QACAA,OAAAK,IAAAR,EAAAC,KAAAC,QAEAC,OAAAM,QAAA,KAAA,SAAAA,QAAA,KAAA,QAAAA,QAAA,UAAA,MAIAJ,KAAA,SAAAK,GACA,MAAAC,QAAAC,UAAAC,SAAAC,KAAAJ,GAAAK,MAAA,oBAAA,IAIAC,MAAA,SAAAN,GACA,GAAAL,MAAAL,EAAAC,KAAAI,KAAAK,EAEA,QAAAL,MACA,IAAA,SACA,GAAAW,SAEA,KAAA,GAAAC,OAAAP,GACAA,EAAAQ,eAAAD,OACAD,MAAAC,KAAAjB,EAAAC,KAAAe,MAAAN,EAAAO,MAIA,OAAAD,MAEA,KAAA,QACA,MAAAN,GAAAS,QAGA,MAAAT,KAIAU,WACAC,OAAA,SAAAC,GAAAC,OACA,GAAAxB,MAAAC,EAAAC,KAAAe,MAAAhB,EAAAoB,UAAAE,IAEA,KAAA,GAAAL,OAAAM,OACAxB,KAAAkB,KAAAM,MAAAN,IAGA,OAAAlB,OAYAyB,aAAA,SAAAC,OAAAC,OAAAC,OAAAC,MACAA,KAAAA,MAAA5B,EAAAoB,SACA,IAAAS,SAAAD,KAAAH,OAEA,IAAA,GAAAK,UAAAC,OAAA,CACAJ,OAAAG,UAAA,EAEA,KAAA,GAAAE,YAAAL,QACAA,OAAAT,eAAAc,YACAH,QAAAG,UAAAL,OAAAK,UAIA,OAAAH,SAGA,GAAAI,OAEA,KAAA,GAAAC,SAAAL,SAEA,GAAAA,QAAAX,eAAAgB,OAAA,CAEA,GAAAA,OAAAR,OAEA,IAAA,GAAAM,YAAAL,QAEAA,OAAAT,eAAAc,YACAC,IAAAD,UAAAL,OAAAK,UAKAC,KAAAC,OAAAL,QAAAK,OAWA,MANAlC,GAAAoB,UAAAe,IAAAnC,EAAAoB,UAAA,SAAAH,IAAAmB,OACAA,QAAAR,KAAAH,SAAAR,KAAAQ,SACAY,KAAApB,KAAAgB,OAIAL,KAAAH,QAAAQ,KAIAE,IAAA,SAAAzB,EAAA4B,SAAAjC,MACA,IAAA,GAAAkC,KAAA7B,GACAA,EAAAQ,eAAAqB,KACAD,SAAAxB,KAAAJ,EAAA6B,EAAA7B,EAAA6B,GAAAlC,MAAAkC,GAEA,WAAAvC,EAAAC,KAAAI,KAAAK,EAAA6B,IACAvC,EAAAoB,UAAAe,IAAAzB,EAAA6B,GAAAD,UAEA,UAAAtC,EAAAC,KAAAI,KAAAK,EAAA6B,KACAvC,EAAAoB,UAAAe,IAAAzB,EAAA6B,GAAAD,SAAAC,MAOAC,aAAA,SAAAC,MAAAH,UAGA,IAAA,GAAAI,SAFAC,SAAArD,SAAAsD,iBAAA,oGAEAL,EAAA,EAAAG,QAAAC,SAAAJ,MACAvC,EAAA6C,iBAAAH,QAAAD,SAAA,EAAAH,WAIAO,iBAAA,SAAAH,QAAAD,MAAAH,UAIA,IAFA,GAAAQ,UAAAjB,QAAAkB,OAAAL,QAEAK,SAAAhD,KAAAiD,KAAAD,OAAAE,YACAF,OAAAA,OAAAG,UAQA,IALAH,SACAD,UAAAC,OAAAE,UAAAlC,MAAAhB,QAAA,CAAA,KAAA,GACA8B,QAAA7B,EAAAoB,UAAA0B,WAGAjB,QAAA,CAKAa,QAAAO,UAAAP,QAAAO,UAAAxC,QAAAV,KAAA,IAAAU,QAAA,OAAA,KAAA,aAAAqC,SAGAC,OAAAL,QAAAQ,WAEA,OAAAF,KAAAD,OAAAI,YACAJ,OAAAE,UAAAF,OAAAE,UAAAxC,QAAAV,KAAA,IAAAU,QAAA,OAAA,KAAA,aAAAqC,SAGA,IAAAM,MAAAV,QAAAW,WAEA,IAAAD,KAAA,CAIA,GAAAE,MACAZ,QAAAA,QACAI,SAAAA,SACAjB,QAAAA,QACAuB,KAAAA,KAKA,IAFApD,EAAAuD,MAAAC,IAAA,mBAAAF,KAEAb,OAAA7C,KAAA6D,OAAA,CACA,GAAAC,QAAA,GAAAD,QAAAzD,EAAA2D,SAEAD,QAAAE,UAAA,SAAAC,KACAP,IAAAQ,gBAAA1D,MAAA2D,UAAAC,KAAAC,MAAAJ,IAAAK,MAAApB,UAEA9C,EAAAuD,MAAAC,IAAA,gBAAAF,KAEAA,IAAAZ,QAAAyB,UAAAb,IAAAQ,gBAEAxB,UAAAA,SAAAxB,KAAAwC,IAAAZ,SACA1C,EAAAuD,MAAAC,IAAA,kBAAAF,MAGAI,OAAAU,YAAAJ,KAAAD,WACAjB,SAAAQ,IAAAR,SACAM,KAAAE,IAAAF,YAIAE,KAAAQ,gBAAA9D,EAAAqE,UAAAf,IAAAF,KAAAE,IAAAzB,QAAAyB,IAAAR,UAEA9C,EAAAuD,MAAAC,IAAA,gBAAAF,KAEAA,IAAAZ,QAAAyB,UAAAb,IAAAQ,gBAEAxB,UAAAA,SAAAxB,KAAA4B,SAEA1C,EAAAuD,MAAAC,IAAA,kBAAAF,QAIAe,UAAA,SAAAC,KAAAzC,QAAAiB,UACA,GAAA3C,QAAAH,EAAAuE,SAAAD,KAAAzC,QACA,OAAAzB,OAAA2D,UAAA/D,EAAAC,KAAAC,OAAAC,QAAA2C,WAGAyB,SAAA,SAAAD,KAAAzC,QAAAiB,UACA,GAAA1C,OAAAJ,EAAAI,MAEAoE,QAAAF,MAEAG,KAAA5C,QAAA4C,IAEA,IAAAA,KAAA,CACA,IAAA,GAAAvC,SAAAuC,MACA5C,QAAAK,OAAAuC,KAAAvC,aAGAL,SAAA4C,KAGAC,UAAA,IAAA,GAAAxC,SAAAL,SACA,GAAAA,QAAAX,eAAAgB,QAAAL,QAAAK,OAAA,CAIA,GAAAyC,UAAA9C,QAAAK,MACAyC,UAAA,UAAA3E,EAAAC,KAAAI,KAAAsE,UAAAA,UAAAA,SAEA,KAAA,GAAAC,GAAA,EAAAA,EAAAD,SAAA5C,SAAA6C,EAAA,CACA,GAAAC,SAAAF,SAAAC,GACAnD,OAAAoD,QAAApD,OACAqD,aAAAD,QAAAC,WACAC,iBAAA,EACAxE,MAAAsE,QAAAtE,KAEAsE,SAAAA,QAAAA,SAAAA,OAEA,KAAA,GAAAtC,GAAA,EAAAA,EAAAiC,OAAAzC,OAAAQ,IAAA,CAEA,GAAAyC,KAAAR,OAAAjC,EAEA,IAAAiC,OAAAzC,OAAAuC,KAAAvC,OAEA,KAAA2C,UAGA,MAAAM,cAAA5E,QAAA,CAIAyE,QAAAI,UAAA,CAEA,IAAAlE,OAAA8D,QAAAK,KAAAF,IAEA,IAAAjE,MAAA,CACA+D,aACAC,iBAAAhE,MAAA,GAAAgB,OAGA,IAAAoD,MAAApE,MAAAqE,MAAA,EAAAL,iBACAhE,MAAAA,MAAA,GAAAI,MAAA4D,kBACAM,IAAAtE,MAAAgB,OACAuD,GAAAH,KAAAE,IACA3D,OAAAsD,IAAA7D,MAAA,EAAAgE,KAAA,GACAI,MAAAP,IAAA7D,MAAAmE,GAAA,GAEAE,MAAAjD,EAAA,EAEAb,SACA8D,KAAAC,KAAA/D,OAGA,IAAAgE,SAAA,GAAAtF,OAAA8B,MAAAT,OAAAzB,EAAAuE,SAAAxD,MAAAU,QAAAV,MAAAR,MAEAiF,MAAAC,KAAAC,SAEAH,OACAC,KAAAC,KAAAF,OAGAI,MAAA/E,UAAAgF,OAAAC,MAAArB,OAAAgB,UAMA,MAAAhB,SAGAjB,OACAuC,OAEAnG,IAAA,SAAAoG,KAAAzD,UACA,GAAAiB,OAAAvD,EAAAuD,MAAAuC,GAEAvC,OAAAwC,MAAAxC,MAAAwC,UAEAxC,MAAAwC,MAAAN,KAAAnD,WAGAkB,IAAA,SAAAuC,KAAAzC,KACA,GAAA0C,WAAAhG,EAAAuD,MAAAuC,IAAAC,KAEA,IAAAC,WAAAA,UAAAjE,OAIA,IAAA,GAAAO,UAAAC,EAAA,EAAAD,SAAA0D,UAAAzD,MACAD,SAAAgB,QAMAlD,MAAAJ,EAAAI,MAAA,SAAAC,KAAAC,QAAAC,OACA8B,KAAAhC,KAAAA,KACAgC,KAAA/B,QAAAA,QACA+B,KAAA9B,MAAAA,MA6CA,IA1CAH,MAAA2D,UAAA,SAAArD,EAAAoC,SAAAC,QACA,GAAA,gBAAArC,GACA,MAAAA,EAGA,IAAA,kBAAAC,OAAAC,UAAAC,SAAAC,KAAAJ,GACA,MAAAA,GAAAF,IAAA,SAAAkC,SACA,MAAAtC,OAAA2D,UAAArB,QAAAI,SAAApC,KACAuF,KAAA,GAGA,IAAA3C,MACAjD,KAAAK,EAAAL,KACAC,QAAAF,MAAA2D,UAAArD,EAAAJ,QAAAwC,SAAAC,QACAmD,IAAA,OACAC,SAAA,QAAAzF,EAAAL,MACA+F,cACAtD,SAAAA,SACAC,OAAAA,OAOA,IAJA,WAAAO,IAAAjD,OACAiD,IAAA8C,WAAA,WAAA,QAGA1F,EAAAH,MAAA,CACA,GAAA8F,SAAA,UAAArG,EAAAC,KAAAI,KAAAK,EAAAH,OAAAG,EAAAH,OAAAG,EAAAH,MACAoF,OAAA/E,UAAA6E,KAAAI,MAAAvC,IAAA6C,QAAAE,SAGArG,EAAAuD,MAAAC,IAAA,OAAAF,IAEA,IAAA8C,YAAA,EAEA,KAAA,GAAAL,QAAAzC,KAAA8C,WACAA,YAAAL,KAAA,MAAAzC,IAAA8C,WAAAL,OAAA,IAAA,GAGA,OAAA,IAAAzC,IAAA4C,IAAA,WAAA5C,IAAA6C,QAAAF,KAAA,KAAA,KAAAG,WAAA,IAAA9C,IAAAhD,QAAA,KAAAgD,IAAA4C,IAAA,MAIAtG,KAAAN,SACA,MAAAM,MAAA0G,kBAKA1G,KAAA0G,iBAAA,UAAA,SAAAzC,KACA,GAAA0C,SAAAvC,KAAAC,MAAAJ,IAAAK,MACAnE,KAAAwG,QAAAzD,SACAM,KAAAmD,QAAAnD,IAEAxD,MAAAwE,YAAAJ,KAAAD,UAAA/D,EAAAC,KAAAC,OAAAF,EAAAuE,SAAAnB,KAAApD,EAAAoB,UAAArB,UACAH,KAAA4G,UACA,GAEA5G,KAAAE,OAZAF,KAAAE,KAgBA,IAAA2G,QAAAnH,SAAAoH,qBAAA,SAYA,OAVAD,QAAAA,OAAAA,OAAA1E,OAAA,GAEA0E,SACAzG,EAAA2D,SAAA8C,OAAAE,IAEArH,SAAAgH,mBAAAG,OAAAG,aAAA,gBACAtH,SAAAgH,iBAAA,mBAAAtG,EAAAwC,eAIA5C,KAAAE,QAIA,oBAAA+G,SAAAA,OAAAC,UACAD,OAAAC,QAAAhH,OAGAA,MAAAsB,UAAA2F,QACAC,QAAA,mBACAC,OAAA,YACAC,QAAA,gBACAC,MAAA,0BACAjB,KACArB,QAAA,kFACApD,QACAyE,KACArB,QAAA,gBACApD,QACA2F,YAAA,QACAC,UAAA,cAGAC,cACAzC,QAAA,mCACApD,QACA2F,YAAA,WAGAA,YAAA,QACAG,aACA1C,QAAA,WACApD,QACA4F,UAAA,gBAMAG,OAAA,uBAIA1H,MAAAyD,MAAA5D,IAAA,OAAA,SAAA2D,KAEA,WAAAA,IAAAjD,OACAiD,IAAA8C,WAAA,MAAA9C,IAAAhD,QAAAG,QAAA,QAAA,QAIAX,MAAAsB,UAAAqG,KACAT,QAAA,oBACAU,QACA7C,QAAA,4BACApD,QACA2F,YAAA,UAGAO,IAAA,wBACAC,SAAA,+BACAC,SAAA,0BACAC,OAAA,mBACAC,UAAA,mBACAX,YAAA,YACAY,WAAA,sBAGAlI,MAAAsB,UAAA2F,SACAjH,MAAAsB,UAAAI,aAAA,SAAA,OACAyG,OACApD,QAAA,qCACApD,QACAyE,KACArB,QAAA,8BACApD,OAAA3B,MAAAsB,UAAA2F,OAAAb,IAAAzE,QAEAgD,KAAA3E,MAAAsB,UAAAqG,KAEAlH,MAAA,kBAIAT,MAAAsB,UAAAI,aAAA,SAAA,cACA0G,cACArD,QAAA,wBACApD,QACA8F,aACA1C,QAAA,cACApD,OAAA3B,MAAAsB,UAAA2F,OAAAb,IAAAzE,QAEA2F,YAAA,wBACAE,cACAzC,QAAA,OACApD,OAAA3B,MAAAsB,UAAAqG,MAGAlH,MAAA,iBAEAT,MAAAsB,UAAA2F,OAAAb,MAEApG,MAAAsB,UAAAqG,IAAAG,UACA/C,QAAA,8BACApD,QACA0G,iBAAA,gEACAC,eAAA,sBACAC,QAAA,eACA/G,GAAA,gBAIAxB,MAAAsB,UAAAI,aAAA,MAAA,UACA8G,QAAA,kBACAd,OAAA,mBACAe,OAAA,cAEAzI,MAAAsB,UAAAoH,OACAxB,UAEAnC,QAAA,6BACAC,YAAA,IAGAD,QAAA,8BACAC,YAAA,IAGAgD,OAAA,mBACAW,cACA5D,QAAA,sGACAC,YAAA,EACArD,QACA2F,YAAA,YAGAsB,QAAA,4GACAC,UAAA,oBACAX,YACAnD,QAAA,iBACApD,QACA2F,YAAA,OAGAmB,OAAA,+CACAK,SAAA,6DACAC,OAAA,kBACAzB,YAAA,kBAGAtH,MAAAsB,UAAA0H,WAAAhJ,MAAAsB,UAAAC,OAAA,SACAqH,QAAA,iTACAH,OAAA,gEAGAzI,MAAAsB,UAAAI,aAAA,aAAA,WACAuH,OACAlE,QAAA,8EACAC,YAAA,KAIAhF,MAAAsB,UAAA2F,QACAjH,MAAAsB,UAAAI,aAAA,SAAA,OACAiF,QACA5B,QAAA,uCACApD,QACAyE,KACArB,QAAA,gCACApD,OAAA3B,MAAAsB,UAAA2F,OAAAb,IAAAzE,QAEAgD,KAAA3E,MAAAsB,UAAA0H,YAEAvI,MAAA,yBAKAT,MAAAsB,UAAA4H,KAAAlJ,MAAAsB,UAAAC,OAAA,SACA2F,SACAnC,QAAA,8BACAC,YAAA,GAEAgD,QAEAjD,QAAA,wBACApD,QAEAoG,SAAA,2CAGAa,QAAA,4HAGA5I,MAAAsB,UAAAI,aAAA,OAAA,WAEAqG,SAAA,0CAEA/H,MAAAsB,UAAAI,aAAA,OAAA,WAEAuG,UAAA,2CAGAjI,MAAAsB,UAAA6H,KAUAjC,QAAA,SAKAc,OAAA,oBAOAoB,SACArE,QAAA,iBACApD,QAOA0H,UAAA,iBAiBAC,MAAA,YAKAC,QAAA,cACAC,SAAA,gBAYAC,YAAA","file":"main.js","sourcesContent":["if('querySelector' in document && 'classList' in document.createElement('a') && 'addEventListener' in window) {\n\n  /* http://prismjs.com/download.html?themes=prism&languages=markup+css+css-extras+clike+javascript+bash+git */\n  self = (typeof window !== 'undefined')\n    ? window   // if in browser\n    : (\n      (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n      ? self // if in worker\n      : {}   // if in node js\n    );\n\n  /**\n  * Prism: Lightweight, robust, elegant syntax highlighting\n  * MIT license http://www.opensource.org/licenses/mit-license.php/\n  * @author Lea Verou http://lea.verou.me\n  */\n\n  var Prism = (function(){\n\n  // Private helper vars\n  var lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\n  var _ = self.Prism = {\n    util: {\n      encode: function (tokens) {\n        if (tokens instanceof Token) {\n          return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n        } else if (_.util.type(tokens) === 'Array') {\n          return tokens.map(_.util.encode);\n        } else {\n          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      type: function (o) {\n        return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n      },\n\n      // Deep clone a language definition (e.g. to extend it)\n      clone: function (o) {\n        var type = _.util.type(o);\n\n        switch (type) {\n          case 'Object':\n            var clone = {};\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = _.util.clone(o[key]);\n              }\n            }\n\n            return clone;\n\n          case 'Array':\n            return o.slice();\n        }\n\n        return o;\n      }\n    },\n\n    languages: {\n      extend: function (id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n      * Insert a token before another token in a language literal\n      * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n      * we cannot just provide an object, we need anobject and a key.\n      * @param inside The key (or language id) of the parent\n      * @param before The key to insert before. If not provided, the function appends instead.\n      * @param insert Object with the key/value pairs to insert\n      * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n      */\n      insertBefore: function (inside, before, insert, root) {\n        root = root || _.languages;\n        var grammar = root[inside];\n\n        if (arguments.length == 2) {\n          insert = arguments[1];\n\n          for (var newToken in insert) {\n            if (insert.hasOwnProperty(newToken)) {\n              grammar[newToken] = insert[newToken];\n            }\n          }\n\n          return grammar;\n        }\n\n        var ret = {};\n\n        for (var token in grammar) {\n\n          if (grammar.hasOwnProperty(token)) {\n\n            if (token == before) {\n\n              for (var newToken in insert) {\n\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            }\n\n            ret[token] = grammar[token];\n          }\n        }\n\n        // Update references in other language definitions\n        _.languages.DFS(_.languages, function(key, value) {\n          if (value === root[inside] && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return root[inside] = ret;\n      },\n\n      // Traverse a language definition with Depth First Search\n      DFS: function(o, callback, type) {\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n\n            if (_.util.type(o[i]) === 'Object') {\n              _.languages.DFS(o[i], callback);\n            }\n            else if (_.util.type(o[i]) === 'Array') {\n              _.languages.DFS(o[i], callback, i);\n            }\n          }\n        }\n      }\n    },\n\n    highlightAll: function(async, callback) {\n      var elements = document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code');\n\n      for (var i=0, element; element = elements[i++];) {\n        _.highlightElement(element, async === true, callback);\n      }\n    },\n\n    highlightElement: function(element, async, callback) {\n      // Find language\n      var language, grammar, parent = element;\n\n      while (parent && !lang.test(parent.className)) {\n        parent = parent.parentNode;\n      }\n\n      if (parent) {\n        language = (parent.className.match(lang) || [,''])[1];\n        grammar = _.languages[language];\n      }\n\n      if (!grammar) {\n        return;\n      }\n\n      // Set language on the element, if not present\n      element.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n      // Set language on the parent, for styling\n      parent = element.parentNode;\n\n      if (/pre/i.test(parent.nodeName)) {\n        parent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n      }\n\n      var code = element.textContent;\n\n      if(!code) {\n        return;\n      }\n\n      var env = {\n        element: element,\n        language: language,\n        grammar: grammar,\n        code: code\n      };\n\n      _.hooks.run('before-highlight', env);\n\n      if (async && self.Worker) {\n        var worker = new Worker(_.filename);\n\n        worker.onmessage = function(evt) {\n          env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n          _.hooks.run('before-insert', env);\n\n          env.element.innerHTML = env.highlightedCode;\n\n          callback && callback.call(env.element);\n          _.hooks.run('after-highlight', env);\n        };\n\n        worker.postMessage(JSON.stringify({\n          language: env.language,\n          code: env.code\n        }));\n      }\n      else {\n        env.highlightedCode = _.highlight(env.code, env.grammar, env.language)\n\n        _.hooks.run('before-insert', env);\n\n        env.element.innerHTML = env.highlightedCode;\n\n        callback && callback.call(element);\n\n        _.hooks.run('after-highlight', env);\n      }\n    },\n\n    highlight: function (text, grammar, language) {\n      var tokens = _.tokenize(text, grammar);\n      return Token.stringify(_.util.encode(tokens), language);\n    },\n\n    tokenize: function(text, grammar, language) {\n      var Token = _.Token;\n\n      var strarr = [text];\n\n      var rest = grammar.rest;\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      tokenloop: for (var token in grammar) {\n        if(!grammar.hasOwnProperty(token) || !grammar[token]) {\n          continue;\n        }\n\n        var patterns = grammar[token];\n        patterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n\n        for (var j = 0; j < patterns.length; ++j) {\n          var pattern = patterns[j],\n            inside = pattern.inside,\n            lookbehind = !!pattern.lookbehind,\n            lookbehindLength = 0,\n            alias = pattern.alias;\n\n          pattern = pattern.pattern || pattern;\n\n          for (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\n\n            var str = strarr[i];\n\n            if (strarr.length > text.length) {\n              // Something went terribly wrong, ABORT, ABORT!\n              break tokenloop;\n            }\n\n            if (str instanceof Token) {\n              continue;\n            }\n\n            pattern.lastIndex = 0;\n\n            var match = pattern.exec(str);\n\n            if (match) {\n              if(lookbehind) {\n                lookbehindLength = match[1].length;\n              }\n\n              var from = match.index - 1 + lookbehindLength,\n                match = match[0].slice(lookbehindLength),\n                len = match.length,\n                to = from + len,\n                before = str.slice(0, from + 1),\n                after = str.slice(to + 1);\n\n              var args = [i, 1];\n\n              if (before) {\n                args.push(before);\n              }\n\n              var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);\n\n              args.push(wrapped);\n\n              if (after) {\n                args.push(after);\n              }\n\n              Array.prototype.splice.apply(strarr, args);\n            }\n          }\n        }\n      }\n\n      return strarr;\n    },\n\n    hooks: {\n      all: {},\n\n      add: function (name, callback) {\n        var hooks = _.hooks.all;\n\n        hooks[name] = hooks[name] || [];\n\n        hooks[name].push(callback);\n      },\n\n      run: function (name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i=0, callback; callback = callbacks[i++];) {\n          callback(env);\n        }\n      }\n    }\n  };\n\n  var Token = _.Token = function(type, content, alias) {\n    this.type = type;\n    this.content = content;\n    this.alias = alias;\n  };\n\n  Token.stringify = function(o, language, parent) {\n    if (typeof o == 'string') {\n      return o;\n    }\n\n    if (Object.prototype.toString.call(o) == '[object Array]') {\n      return o.map(function(element) {\n        return Token.stringify(element, language, o);\n      }).join('');\n    }\n\n    var env = {\n      type: o.type,\n      content: Token.stringify(o.content, language, parent),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language,\n      parent: parent\n    };\n\n    if (env.type == 'comment') {\n      env.attributes['spellcheck'] = 'true';\n    }\n\n    if (o.alias) {\n      var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n      Array.prototype.push.apply(env.classes, aliases);\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n\n    for (var name in env.attributes) {\n      attributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n    }\n\n    return '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\n\n  };\n\n  if (!self.document) {\n    if (!self.addEventListener) {\n      // in Node.js\n      return self.Prism;\n    }\n    // In worker\n    self.addEventListener('message', function(evt) {\n      var message = JSON.parse(evt.data),\n          lang = message.language,\n          code = message.code;\n\n      self.postMessage(JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang]))));\n      self.close();\n    }, false);\n\n    return self.Prism;\n  }\n\n  // Get current script and highlight\n  var script = document.getElementsByTagName('script');\n\n  script = script[script.length - 1];\n\n  if (script) {\n    _.filename = script.src;\n\n    if (document.addEventListener && !script.hasAttribute('data-manual')) {\n      document.addEventListener('DOMContentLoaded', _.highlightAll);\n    }\n  }\n\n  return self.Prism;\n\n  })();\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Prism;\n  }\n  ;\n  Prism.languages.markup = {\n    'comment': /<!--[\\w\\W]*?-->/g,\n    'prolog': /<\\?.+?\\?>/,\n    'doctype': /<!DOCTYPE.+?>/,\n    'cdata': /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n    'tag': {\n      pattern: /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/gi,\n      inside: {\n        'tag': {\n          pattern: /^<\\/?[\\w:-]+/i,\n          inside: {\n            'punctuation': /^<\\/?/,\n            'namespace': /^[\\w-]+?:/\n          }\n        },\n        'attr-value': {\n          pattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/gi,\n          inside: {\n            'punctuation': /=|>|\"/g\n          }\n        },\n        'punctuation': /\\/?>/g,\n        'attr-name': {\n          pattern: /[\\w:-]+/g,\n          inside: {\n            'namespace': /^[\\w-]+?:/\n          }\n        }\n\n      }\n    },\n    'entity': /\\&#?[\\da-z]{1,8};/gi\n  };\n\n  // Plugin to make entity title show the real entity, idea by Roman Komarov\n  Prism.hooks.add('wrap', function(env) {\n\n    if (env.type === 'entity') {\n      env.attributes['title'] = env.content.replace(/&amp;/, '&');\n    }\n  });\n  ;\n  Prism.languages.css = {\n    'comment': /\\/\\*[\\w\\W]*?\\*\\//g,\n    'atrule': {\n      pattern: /@[\\w-]+?.*?(;|(?=\\s*{))/gi,\n      inside: {\n        'punctuation': /[;:]/g\n      }\n    },\n    'url': /url\\(([\"']?).*?\\1\\)/gi,\n    'selector': /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/g,\n    'property': /(\\b|\\B)[\\w-]+(?=\\s*:)/ig,\n    'string': /(\"|')(\\\\?.)*?\\1/g,\n    'important': /\\B!important\\b/gi,\n    'punctuation': /[\\{\\};:]/g,\n    'function': /[-a-z0-9]+(?=\\()/ig\n  };\n\n  if (Prism.languages.markup) {\n    Prism.languages.insertBefore('markup', 'tag', {\n      'style': {\n        pattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/ig,\n        inside: {\n          'tag': {\n            pattern: /<style[\\w\\W]*?>|<\\/style>/ig,\n            inside: Prism.languages.markup.tag.inside\n          },\n          rest: Prism.languages.css\n        },\n        alias: 'language-css'\n      }\n    });\n\n    Prism.languages.insertBefore('inside', 'attr-value', {\n      'style-attr': {\n        pattern: /\\s*style=(\"|').+?\\1/ig,\n        inside: {\n          'attr-name': {\n            pattern: /^\\s*style/ig,\n            inside: Prism.languages.markup.tag.inside\n          },\n          'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n          'attr-value': {\n            pattern: /.+/gi,\n            inside: Prism.languages.css\n          }\n        },\n        alias: 'language-css'\n      }\n    }, Prism.languages.markup.tag);\n  };\n  Prism.languages.css.selector = {\n    pattern: /[^\\{\\}\\s][^\\{\\}]*(?=\\s*\\{)/g,\n    inside: {\n      'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/g,\n      'pseudo-class': /:[-\\w]+(?:\\(.*\\))?/g,\n      'class': /\\.[-:\\.\\w]+/g,\n      'id': /#[-:\\.\\w]+/g\n    }\n  };\n\n  Prism.languages.insertBefore('css', 'ignore', {\n    'hexcode': /#[\\da-f]{3,6}/gi,\n    'entity': /\\\\[\\da-f]{1,8}/gi,\n    'number': /[\\d%\\.]+/g\n  });;\n  Prism.languages.clike = {\n    'comment': [\n      {\n        pattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//g,\n        lookbehind: true\n      },\n      {\n        pattern: /(^|[^\\\\:])\\/\\/.*?(\\r?\\n|$)/g,\n        lookbehind: true\n      }\n    ],\n    'string': /(\"|')(\\\\?.)*?\\1/g,\n    'class-name': {\n      pattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/ig,\n      lookbehind: true,\n      inside: {\n        punctuation: /(\\.|\\\\)/\n      }\n    },\n    'keyword': /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/g,\n    'boolean': /\\b(true|false)\\b/g,\n    'function': {\n      pattern: /[a-z0-9_]+\\(/ig,\n      inside: {\n        punctuation: /\\(/\n      }\n    },\n    'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,\n    'operator': /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|\\~|\\^|\\%/g,\n    'ignore': /&(lt|gt|amp);/gi,\n    'punctuation': /[{}[\\];(),.:]/g\n  };\n  ;\n  Prism.languages.javascript = Prism.languages.extend('clike', {\n    'keyword': /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/g,\n    'number': /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?|NaN|-?Infinity)\\b/g\n  });\n\n  Prism.languages.insertBefore('javascript', 'keyword', {\n    'regex': {\n      pattern: /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/g,\n      lookbehind: true\n    }\n  });\n\n  if (Prism.languages.markup) {\n    Prism.languages.insertBefore('markup', 'tag', {\n      'script': {\n        pattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/ig,\n        inside: {\n          'tag': {\n            pattern: /<script[\\w\\W]*?>|<\\/script>/ig,\n            inside: Prism.languages.markup.tag.inside\n          },\n          rest: Prism.languages.javascript\n        },\n        alias: 'language-javascript'\n      }\n    });\n  }\n  ;\n  Prism.languages.bash = Prism.languages.extend('clike', {\n    'comment': {\n      pattern: /(^|[^\"{\\\\])(#.*?(\\r?\\n|$))/g,\n      lookbehind: true\n    },\n    'string': {\n      //allow multiline string\n      pattern: /(\"|')(\\\\?[\\s\\S])*?\\1/g,\n      inside: {\n        //'property' class reused for bash variables\n        'property': /\\$([a-zA-Z0-9_#\\?\\-\\*!@]+|\\{[^\\}]+\\})/g\n      }\n    },\n    'keyword': /\\b(if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)\\b/g\n  });\n\n  Prism.languages.insertBefore('bash', 'keyword', {\n    //'property' class reused for bash variables\n    'property': /\\$([a-zA-Z0-9_#\\?\\-\\*!@]+|\\{[^}]+\\})/g\n  });\n  Prism.languages.insertBefore('bash', 'comment', {\n    //shebang must be before comment, 'important' class from css reused\n    'important': /(^#!\\s*\\/bin\\/bash)|(^#!\\s*\\/bin\\/sh)/g\n  });\n  ;\n  Prism.languages.git = {\n    /*\n    * A simple one line comment like in a git status command\n    * For instance:\n    * $ git status\n    * # On branch infinite-scroll\n    * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n    * # and have 1 and 2 different commits each, respectively.\n    * nothing to commit (working directory clean)\n    */\n    'comment': /^#.*$/m,\n\n    /*\n    * a string (double and simple quote)\n    */\n    'string': /(\"|')(\\\\?.)*?\\1/gm,\n\n    /*\n    * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n    * For instance:\n    * $ git add file.txt\n    */\n    'command': {\n      pattern: /^.*\\$ git .*$/m,\n      inside: {\n        /*\n        * A git command can contain a parameter starting by a single or a double dash followed by a string\n        * For instance:\n        * $ git diff --cached\n        * $ git log -p\n        */\n        'parameter': /\\s(--|-)\\w+/m\n      }\n    },\n\n    /*\n    * Coordinates displayed in a git diff command\n    * For instance:\n    * $ git diff\n    * diff --git file.txt file.txt\n    * index 6214953..1d54a52 100644\n    * --- file.txt\n    * +++ file.txt\n    * @@ -1 +1,2 @@\n    * -Here's my tetx file\n    * +Here's my text file\n    * +And this is the second line\n    */\n    'coord': /^@@.*@@$/m,\n\n    /*\n    * Regexp to match the changed lines in a git diff output. Check the example above.\n    */\n    'deleted': /^-(?!-).+$/m,\n    'inserted': /^\\+(?!\\+).+$/m,\n\n    /*\n    * Match a \"commit [SHA1]\" line in a git log output.\n    * For instance:\n    * $ git log\n    * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n    * Author: lgiraudel\n    * Date:   Mon Feb 17 11:18:34 2014 +0100\n    *\n    *     Add of a new line\n    */\n    'commit_sha1': /^commit \\w{40}$/m\n  };\n  ;\n}\n","/**\n * main.js\n *\n * Only runs in modern browsers via feature detection\n * Requires support for querySelector, classList and addEventListener\n */\n\nif('querySelector' in document && 'classList' in document.createElement('a') && 'addEventListener' in window) {\n\n  // Add class \"js\" to html element\n  document.querySelector('html').classList.add('js');\n\n}\n"],"sourceRoot":"/source/"}